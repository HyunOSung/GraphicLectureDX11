보통 부모클래스로 한번에 묶는데

Actor

Tick()
Render()
// 이 부분은 전부 순수 가상함수로, 자식 클래스에서 다시 구현해야 함


맵 상속 변경

맵 헤더에 틱, 렌더 정의
클래스에서 함수 구현

억지로 뭔가를 구현할 필요가 없다.
필요한 것만 구현할 것

틱에서 부모쪽 틱 함수를 호출

기능을 먼저 설계하고 없다면 만들거나 찾아내야 함

렌더에서 

유틸 클래스 생성
SetXY
SetObject

GIT 배시 물어보기



헬로 월드
	- 빌드 환경 설정
	- 제일 간단한 프로그램, 이 프로그램의 구조
상수
자료형
연산자
변수 선언
배열
반복문
조건문
포인터
함수
	- 여기까지가 언어 기본
구조체/클래스
클래스 설계
데이터 모딜링
게임 만들기
상속
다형성(오버라이딩, virtual, override)
클래스 관계(is a, has a)
const, overload
게임 엔진 구조
while(1)
{
	Input()
	Tick()
	Render()
}

알고리즘의 기본 : 시공간 절약
메모리를 더 쓸 것이냐, CPU를 더 쓸 것이냐.

벡터라 한다면 모든 자료가 전부 가능해야 한다

STL 벡터(수학 벡터와 다름)
	크기가 바뀌는 배열(저장소)

벡터의 구현
	자료 저장 공간 - 동적으로 할당이 가능
	크기에 대한 정보
	위치
	
	자료 추가(제일 뒤에 추가)
		동적할당을 하면서 자료를 유지
		- 성능 업, 메모리를 쓴다.
	자료 읽어오기(연산자 오버로딩, [])


템플릿은 헤더 쪽에 전부 집어넣어야 함

inline 물어보기
- 컴파일러가 자동으로 시켜주는 최적화(옵션에 있음)


저장소 생성
저장소에 데이터 집어넣기
저장소에 집어넣은 데이터 삭제
저장소에 집어넣은 특정 데이터 삭제
저장소에 생긴 빈 공간에 데이터 추가



템플릿이란 어떤 형태로든 적용해서 자동으로 컴파일해줄 수 있게 하는 것



메모리 공간을 동적으로 만들어보자.
그래서 한게 배열이었는데 일일히 해줘야 하는 단점이 있다.
그래서 벡터를 구현해보는 것

기본 형태로는 동적 작업이 불가능

컴퓨터 구조상 메모리가 설정되면 늘이는 게 불가능
사이즈가 변화하면 메모리를 옮기고 다시 설정해야 함

규모 설정 - 데이터 입력 - 규모 재설정 - 데이터 복사 - 재할당 - 데이터 추가 및 다시 입력

변수가 같은데 두개가 다르면 차라리 변수를 각각 만들어주기

추가.
	1. 자료 저장소 충분
		추가 위치 정보를 한칸 이동
		추가 위치 추가 정보 기록
	2. 자료 저장소 부족
		자료 저장소 늘리기
		추가 위치 정보를 한칸 이동
		추가 위치 추가 정보 기록

	//단 조건
		인덱스 범위 체크

번역 ->C++

알고리즘 정당성 증명
반복문 불변식


// 문제 1
////네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다.
////그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다.
////다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.
////
////지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 “공백”(“ “) 또는 “벽”(“#”) 두 종류로 이루어져 있다.
////전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다.
////각각 “지도 1”과 “지도 2”라고 하자.지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다.
////지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
////“지도 1”과 “지도 2”는 각각 정수 배열로 암호화되어 있다.
////암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.
////
////입력 형식
////입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.
////
////1 ? n ? 16
////arr1, arr2는 길이 n인 정수 배열로 주어진다.
////정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다.즉, 0 ? x ? 2 ^ n - 1을 만족한다.
////출력 형식
////원래의 비밀지도를 해독하여 "#", 공백으로 구성된 문자열 배열로 출력하라.
//

문제 1
01001 = {' ','#',' ',' ','#'}
공백과 #으로 변환
둘 중 하나가 #이라면 #
둘 다 공백이라면 공백


입력 받은 수가 16이하 1이상인지 확인
입력 받은 수에 따라서 랜덤 배열 2개 생성
	배열 각 인자는 최대(16) 최소값(1)을 따름
각 인자를 2진수로 변환
변환된 인자 비교식


두 배열 비교
신규 배열 출력


//문제 2
//숫자 X보다 크거나 같은 수 중 가장 작은 2의 승수(2^ㅜ)를 NPOT(Next Power of Two)라고 할 때, 주어진 숫자 N개의 NPOT를 구하여 모두 XOR 한 값을 구하시오.
//
//조건
//1<X<2^63
//1<=N<2^18
//
//입력
//3//숫자의 개수
//3
//5
//7
//
//출력
//4
//
//4 = 4^8(4 xor 8 xor 8)


string iterator : 하나하나 전부 검색

scanf로 double이나 float형을 입력 받을 때는 %.1f 등으로 소수점 길이까지 지정을 해서 입력을 받아줘야 하고
printf로 출력을 할 때도 소수점 길이까지 지정을 해서 출력을 해줘야 한다. 

링크드 리스트 중요함, 만들어볼것


스택, 큐

분할정복
- 기능을 최대한 분할해서 구현한 다음에 하나로 합치기


재귀함수, 재귀 알고리즘
- 자기 자신을 호출해야 한다.

% 연산자를 사용하면 해당 값보다 낮은수가 반드시 나온다.
- 나머지를 보여주기 때문
난수 생성은 time.h를 통해서
srand((unsigned int)time(0));


printf("%d %d", (a,b))로 출력하면 왜 값이 이상하게 나오는가?
-()를 하게 되면 인수를 하나로 인식한다.
-, 연산자는 다음 수를 보여주므로 b를 출력하고 남은 곳에는 더미 데이터가 들어가게 된다.
오후 10:24 2019-07-04
최대공약수 구하기
- 조건이 맞으면 큰수를 더 작은 수로 나눠서 작은 수를 -1씩 해서 계속해서 큰 수를 나눠준다. 나눈 수로 원래 작은 수 원본이 나눠지는 수가 최대 공약수가 된다.

소인수 찾기
- while문 도는 동안 나머지가 0이면 원수를 첫 인수(2)로 나누고 나눈 a를 저장한다. 그리고 나누는데 성공한 인수는 출력하고 그대로 유지한다.
- 만일 나누는데 실패한다면 인수에 1을 더해서 다시 나눈다.
- 체크는 성공한 인수를 따로 받아서 인수들끼리만 곱한 수를 원수와 비교해서 같으면 탈출한다.

파이 무한급수
#include<iostream>
#include<stdio.h>
#include<time.h>

using namespace std;

int main()
{
	int a = 10000;
	float pi = 0;

	for (int j = 0; j < 10; ++j)
	{

		printf("%d\n", a);
		pi = 0;
		for (int i = 0; i < a + 1; ++i)
		{
			float var = 1.0f / ((2.0f*(float)i) + 1.0f);
			if (i % 2 == 0)
			{
				pi = pi + var;
			}
			else
			{
				pi = pi - var;
			}
			if (i != 0 && i % a == 0)
			{
				printf("%f\n", 4.0f * pi);
			}
		}

		a = a + 10000;
	}
	return 0;
}

- 각각 개별로 독립된 값을 구하고 싶다면 루프 처음에 구하고 싶은 대상을 초기화 시켜줘야 한다.




정수 자릿값 더하기
#include<iostream>
#include<stdio.h>
#include<time.h>

using namespace std;

int SumDigits(long n)
{
	int q = 1;	// 나눗셈을 할 수
	int w = 0;  // 자리수

	bool cal1 = false;
	bool cal2 = false;
	while (cal1 == false)
	{	
		q = q * 10;
		if (n / q == 0)
		{
			q = q / 10;
			while (cal2 == false)
			{
				if (n / q != 0)
				{
					w = w + (n / q);
					n = n % q;
				}
				if (q == 1)
				{
					cal2 = true;					
					n = w;
				}
				q = q  / 10;
			}
			cal1 = true;
		}
	}
	return w;
}

int main()
{
	long a = 0;

	cin >> a;

	a = SumDigits(a);

	cout << a << endl;

	return 0;
}

- 초기화 정말 중요함. 일일히 다 해줘야 함. 잊지 말것


정수 역출력
- 자릿수를 하나하나 다 받아서 역순으로 다시 출력하기

#include<iostream>
#include<stdio.h>
#include<time.h>

using namespace std;

int ReverseOut(long n)
{
	int q = 1;	// 나눗셈을 할 수
	int w = 0;  // 자리수
	int e = 1;
	int r = 0;

	bool cal1 = false;
	bool cal2 = false;
	while (cal1 == false)
	{	
		q = q * 10;
		if (n / q == 0)
		{
			q = q / 10;
			r = q;
			while (cal2 == false)
			{
				if (n / q > 0)
				{
					w = w + (n / q) * e;
					n = n % q;
				}
				if (e == r)
				{
					cal2 = true;										
				}
				q = q  / 10;
				e = e * 10;
			}
			cal1 = true;
		}
	}
	return w;
}

int main()
{
	long a = 0;

	cin >> a;

	a = ReverseOut(a);

	cout << a << endl;

	return 0;
}

- 이게 큐 구현 같기도 하고...
- 나머지를 구해서 1부터 곱해서 처음에 나눴던 기준수와 동일해질때까지 반복문을 돌려서 자리수 재배치



파이 무한급수 함수

#include<iostream>
#include<stdio.h>
#include<time.h>

using namespace std;

float Pi(float n)
{
	float q = 0.0f;

	for (int i = 0; i < n; ++i)
	{
		if (i % 2 != 1)
		{
			q = q + (1.0f / ((2.0f * (float)i) + 1.0f));
		}
		else
		{
			q = q - (1.0f / ((2.0f * (float)i) + 1.0f));
		}
	}
	return 4*q;
}

int main()
{
	float a = 0.0f;

	cin >> a;

	a = Pi(a);

	cout << a << endl;

	return 0;
}


- 함수는 첫 설정때 설정한 데이터 유형만 리턴한다.
- int형으로 설정하면 int형만 리턴하는 방식





//배열 동적 초기화 방법 물어보기
- 반복문으로 일일히 전부 초기화 시켜주는 방법이 있음, 셋팅 때 부터 초기화를 동적으로 할 수는 없음


배열 내 중복체크

자기 자신 스킵(j == k)

자기 자신 제외(j != k)
끝까지 비교를 했을 때 중복이 없으면 출력(a[j] != a[k] && k == 9)
끝까지 비교를 했을 때 중복이 있음(a[j] == a[k])
	뒤에 중복 수가 있음
		앞의 수를 출력
	앞에 중복 수가 있음
		출력하지 않고 패스

배열 1개로 하는 건 일단 중단, 너무 어려움
#include<iostream>
#include<stdio.h>
#include<time.h>

using namespace std;

int main()
{
	int a[10] = {5,2,4,8,9,6,3,4,5,2};




	//for (int i = 0; i < 10; ++i)
	//{
	//	cin >> a[i];
	//}
	for (int j = 0; j < 10; ++j)
	{
		for (int k = j; k < 10; ++k)
		{			
			if (a[j] > a[k])
			{
				int q = a[j];
				a[j] = a[k];
				a[k] = q;
			}
		}		
	}

	for (int i = 0; i < 10; ++i)
	{
		if (a[i] != a[i+1])
		{
			cout << a[i] << endl;
		}
	}
	return 0;

}

- 먼저 소팅을 하고 앞뒤가 다르면 출력하도록 해서 성공.


틱택토 배치 및 검사
#include<iostream>
#include<stdio.h>
#include<time.h>

using namespace std;

int a[3][3] = {
	{0,0,0},
	{0,0,0},
	{0,0,0}
};

int main()
{
	srand((unsigned int)time(0));

	int x = 0;
	int y = 0;


	//틱택토 보드 만들기
	for (int i = 0; i < 3; ++i)
	{
		for (int j = 0; j < 3; ++j)
		{
			//틱택토 보드 내에 구성요소 배치
			if (rand() % 2 == 0)
			{
				a[i][j] = { 0 };
				cout << a[i][j] << " | ";
			}
			else
			{
				a[i][j] = { 1 };
				cout << a[i][j] << " | ";
			}
		}
		cout << endl;
	}

	//틱택토 보드 검사
	for (int i = 0; i < 3; ++i)
	{
		if (a[i][0] && a[i][1] && a[i][2] == 1 || 0)
		{
			cout << i << "열은 빙고입니다." << endl;
		}
		
		if (a[0][i] && a[1][i] && a[2][i] == 1 || 0)
		{
			cout << i << "행은 빙고입니다." << endl;
		}
	}




	return 0;
}

- 한 열, 혹은 비교하고 싶은 구성 전체를 동일한 조건으로 통일하고 싶다면 &&가 필요


!!포인터

#include<iostream>
#include<stdio.h>
#include<time.h>

using namespace std;

int main()
{
	int q = 1;
	int *w = &q;

	cout << q << endl; -> 일반 변수 선언 ->1
	cout << w << endl; ->포인터 선언, 주소값만 저장 ->주소
	cout << &q << endl; ->일반 변수의 주소값만 참조 -> 주소
	cout << *w << endl; -> 포인터 변수가 가리키는 주소의 값을 참조해온다. ->1




	return 0;
}


피벗, 파티션 등등
퀵소트 시간복잡도

소팅 별 성능 생각하기

코드는 적게, 성능은 좋게


배열 검사 할 때 값 정확하게 집어 넣어야 함,
우리는 xy로 부르지만 배열 상에선 반대가 된다(y,x)
- 2차원 배열은 세로부터 카운트 한다.

함수 작동 후에 다른 함수가 선언되어있으면 이전 함수에서 해당 함수를 호출하려고 해도 함수 호출이 불가능 하다.



배정민 깃 : baewhv/GitFirst_bjm
https://github.com/baewhv/GitFirst_bjm




큐 : 들어온 순서대로.
스택 : 처음 들어온 자료가 맨 마지막에 나간다.


루트 추적할 땐 큐가 맞을 것 같다.


//해보고 싶은 것들
//1. 큐를 구현해서 탐색 경로 순으로 인쇄
//2. 랜덤하게 시작점과 탈출점 변경
//3. 배열 세트 여러가지를 만들어서 랜덤하게 4방향 배치한 맵 만들기
//4. 키 만들어서 획득하고 탈출하는 로직 만들기
//5. 콘솔 상에서 실시간으로 탐색하는 것 볼 수 있게 시각화 하기


const : 상수 : 상시 설정, 값을 바꿀 수 없음, 안이든 밖이든
static : 정적 선언 : 처음부터 메모리에 할당, 타입만 고정, 값을 바꿀수 있음

C# 래핑 : 튜토리얼 수준만 있음



190702 그래픽스 수업 시작

DX는 누가 창을 불러오든 상관안함, 화면 연결만 해주면 됨

언어간 통신은 마샬링이라 함

모르면 검색!

윈도우 명령어  MSDN으로 검색해보기

겟메시지는 메시지 처리 시에 다른 작업을 못함

HBRUSH - NULL을 넣으면 기본색으로 설정됨

msdn winmain :어플리케이션 엔트리 포인트(진입점)

윈도우 창 그리기 강좌

프로젝트 설정 - 멀티 바이트 설정이 디폴트
셰이더 설정 때는 유니코드로 설정해야 됨



190702 집

슈도코드
정수 2개 입력

2부터 각각 나누기 시작
	2(나눔수)로 나눌 수 있으면 배열에 2(나눔수)를 추가
		계속해서 2(나눔수)로 나눌 수 있으면 count++
	2(나눔수)로 나눌 수 없으면 나눌 수에 +1 추가
	
	나눔수를 계속 곱함
		곱한 나눔수가 원 수와 같으면 break;

두 배열의 [][0]번 수가 같은 수들이 있는지 비교
	있다면 [][1]번 수를 비교해서 더 높은 쪽의 수를 [][0]번수와 곱
	배열 구성원이 0이 아닐때까지 곱한 수 출력(최소 공배수)

#include<iostream>
#include<stdio.h>
#include<time.h>

using namespace std;

int main()
{

	//최소 공배수 구하기
	//입력 2개 받아서 두 수의 최소 공배수를 구하라.

	int a;
	int b;

	bool EndA = false;
	bool EndB = false;
	bool EndCal = false;


	int multiSetA[10][2] = {};
	int multiSetB[10][2] = {};

	cout << "첫번째 정수를 입력하세요.";
	cin >> a;

	cout << "두번째 정수를 입력하세요.";
	cin >> b;

	int i = 2;
	int j = 0;

	int k = 2;
	int e = 1;

	int l = 0;
	int r = 1;

	int result = 1;

	// 정수 입력 받아서 나누기
	while (EndA == false)
	{		
		if (a%i == 0)
		{		
			a = a / i;
			multiSetA[j][0] = i;
			if (multiSetA[j][0] == i)
			{
				multiSetA[j][1] += 1;
			}
		}
		else if (i%2 != 0) //i가 2의 배수가 아니라면 1 더하기
		{
			i++;
		}
		else
		{
			i++;
			j++;
		}

		if (a == 1)
		{
			EndA = true;
		}
	}

	while (EndB == false)
	{
		if (b%k == 0)
		{
			b = b / k;
			multiSetB[l][0] = k;
			if (multiSetB[l][0] == k)
			{
				multiSetB[l][1] += 1;
			}
		}
		else if (k % 2 != 0) //i가 2의 배수가 아니라면 1 더하기
		{
			k++;
		}
		else
		{
			k++;
			l++;
		}

		if (b == 1)
		{
			EndB = true;
		}
	}
	// 배열 두 개 비교해서 ,0이 같으면 1비교, 1비교에서 더 높은쪽 인수를 반복문 진입으로 곱

	int m = 0;
	int n = 0;


	while (EndCal == false)
	{
		if (multiSetA[m][0] == multiSetB[n][0]) //같은 수가 있다면
		{
			if (multiSetA[m][1] >= multiSetB[n][1])
			{
				for (int i = 0; i < multiSetA[m][1]; ++i)
				{
					result *= multiSetA[m][0];
				}
				m++;
				n++;
			}
			else
			{
				for (int i = 0; i < multiSetB[m][1]; ++i)
				{
					result *= multiSetA[m][0];
				}
				m++;
				n++;
			}
		}
		else if (multiSetA[m][0] != multiSetB[n][0]) //같은수가 없다면
		{
			for (int i = 0; i < multiSetA[m][1]; ++i)
			{
				result *= multiSetA[m][0];
			}
			for (int i = 0; i < multiSetB[m][1]; ++i)
			{
				result *= multiSetA[m][0];
			}

			m++;
			n++;
		}

		if (multiSetA[m][0] == 0)
		{

			cout << result << endl;
			EndCal = true;
			break;
		}
	}
}

- 너무 반복문 범위를 포괄적으로 잡지 말것
- 벡터 공부하기
- 벡터는 배열 크기를 동적으로 할당할 수 있는 유일한 수단







	

LPCSTR
- LP : long pointer : 16 bit
- C : constant : 상수
- STR : 문자열

--CSTR : t_char의미 : 마소 지원 유니코드 기반 스트링


190704 수업내용 덮어쓰기(0703 수업 내용)
- 시작은 0704부터 다시.

- 사람은 가로가 편하지만 컴퓨터는 세로가 편하다
- 전치행렬 공식

-view행렬, camera 행렬은 전부 카메라 관련 정보들

-원근 투영, ~~~행렬

-클러스텀?

--거리가 멀어질 수록 1~100까지 수를 늘리고 줄여서 그림

World View Projection = WVP

DirectX Tex :마소에서 배포하는 무료 DX 라이브러리

DirectXTex.lib를 프로젝트 폴더에 넣기
inl,h 파일도 넣기, 폴더 관리 따로 해서 편하게

라이브러리에 DX 헤더 라이브러리 INL

#pragma once

#include"DXUtill.h"
#include"../Library/DirectXTex.h"

#pragma comment(lib, "../Library/DirectXTex.lib")

using namespace DirectX;

class Texture
{
public:
	Texture();
	~Texture();

private:

	HRESULT GetScratchImage(LPCTSTR


public:
	LPCTSTR fileName; // 이미지 파일 이름(확장자 포함)
	ID3D11ShaderResourceView* textureResourceView;
};



//이미지 파일 읽기 -> 텍스쳐 리소스 만들기
->텍스쳐 리소스에 이미지 데이터 쓰기.
->텍스처 리소스에 접근하는 리소스 뷰 만들기.

//이미지 파일로부터 스크래치 이미지 생성

//오류 확인 함수

//셰이더 리소스 뷰 생성.

//Cpp 부에도 만들기


새로 클래스 소스 추가할 경우 처음 생성된 걸 그대로 사용하면 안된다.
- 처음 생성된걸 제거(삭제X)하고 파일 디렉토리를 옮긴 다음에 다시 추가를 해야 헤더를 인식한다. 

머티리얼과 셰이더는 거의 같은 개념

전통적으로 하는 건 셰이더 코딩

최근에는 그래픽 기반으로 진행

DX는 FBX와 좌표계가 반대

UV좌표계 :
정점 좌표계

CLAMP : 고정
Mirror : 대칭
이외에 반복 등등 있음


복제해서 붙여넣으면 Debug폴더가 생성되고 여기서 경고 메시지를 날리는데 폴더를 한번 날려주자.


C:\Program Files\Autodesk\FBX\FBX SDK\2019.0\include

C:\Program Files\Autodesk\FBX\FBX SDK\2019.0\lib\vs2015\x86\debug


구성을 바꾸게 되면 설적한 디렉터리를 전부 바꿔줘야 한다




190705 수업

원근법
투영행렬

뷰 프러스텀

벡터, 점, 동차 좌표계


그냥 그런 블로그 : 엔진 공부 때 유용
이득우 블로그

프로젝트 복붙해서 볼때는 이전에 열었던 스크립트들 전부 닫고 다시 열것...

버퍼 시각화 - 씬 뎁스





Vector 구현 클래스



190708
- 라이트벡터 * 노멀 벡터 내적 구하기


- 오렌 네이어 공식
	- 난반사 공식
- 위에가 64비트인지 32비트인지 체크할 것


git diff 기능

G버퍼는 디퍼드 렌더링
- 지오메트리 정보를 저장.

- 이전에 UV값이 제대로 안들어오던 문제
	- 셰이더에서 RGB 컬러값을 출력하고는 있는데 받을 값이 없어서 엉뚱한 값이 들어오고 있던것
	- 위치는 VS.fx

C4316 에러, 슬라이드 셰어 

- 숙제 SIMD 공부해오기

SSE

현재 만들고 있는건 로컬 일루미네이션(지역 조명)
정반사광

enlighten engine : 전역 조명 엔진

라이트 셰이딩만을 전문으로 하는 엔진이 있을 정도로 나름 분야가 확립되어있음

퐁 셰이더

반사 벡터 구하기

세미콜론은 제발 체크좀 하자.

반대로 칠해보기
원 리턴은 스페큘러 * 스페큘러 컬러인데
뒤집어서 칠하고 싶다면 인풋되는 스페큘러값의 나머지를 구하면 된다(1에서 스페큘러 값을 뺀 값)

빛의 산란을 구현하려면 라이트 시스템을 아예 따로 빼서 구현해야 한다. 

특정 데이터(sin, cos)를 그림파일로 저장 - Look up 데이터

퐁 셰이더는 동그라미 밖에 못그림

툰 셰이더는 더 옛날 방식으로 구현해야 함, 현대 셰이더는 너무 리얼한 지원을 해주기 때문
좀 더 각진 그래프가 됨

유니티 언리얼 모두 디즈니 모델을 사용함

시멘틱?




190710 DX 수업

- 2개 스폰하기
- 0,2를 변수로 만든 다음 위치만 다르게 하면 될거라고 생각

엔진 첫 시작시 프레임 간격은 없다
모든 엔진이 그렇듯 모든 프레임이 60이 아님, 평균치가 60인것

두 번째 프레임이 지나가야 첫 번째 프레임이 작동한 시간 값을 빼서 프레임 간격을 구한다.
60 fps = 1초 가 1프레임에 1/60초라고 절대적으로 말할 순 없음

북미는 50프레임이 표준

내일은 불린 퐁 셰이더

DX 수업 순서
1. Mesh.h 컬러값 추가  
2. = 컬러값을 받을 수 있는 생성자 추가
3. Mesh.cpp 컬러값 추가 
4. = 색상 서술자 생성
5. Mesh.h 좌표를 설정할 수 있는 세터 설정 
6. = 월드 좌표를 담기 위한 구조 
7. = 쓰레기값이 들어가지 않도록 공간 확보
8. Mesh.cpp 생성 시 좌표를 받을 수 있는 생성자 설정
9. = 상수 버퍼세트 생성
	상수 버퍼 매트릭스 생성
	상수 버퍼 서술자 생성
	상수 버퍼 공간 확보
	상수 배열 정보를 넣어줄 구조체
	상수 버퍼 생성 및 체크
10. VertexShader.h 게터 생성
	리턴하는 개채의 변경을 받음




















































































